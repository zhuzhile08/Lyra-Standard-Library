 ##########################
 # @file Floating.h
 # @author Zhile Zhu (zhuzhile08@gmail.com)
 # 
 # @brief Python file for generating tables required for floating point parsing
 # 
 # @date 2025-03-01
 # 
 # @copyright Copyright (c) 2025
 ##########################

from datetime import datetime
from math import log2

FILE_OPENING = """\
/*************************
 * @file Tables.h
 * @author Zhile Zhu (zhuzhile08@gmail.com)
 * 
 * @brief Tables required for fast lookups in floating point conversion
 * @brief This file was automatically generated by GenTables.py in the same directory. Do NOT modify!
 * 
 * @date {}
 * @copyright Copyright (c) {}
 *************************/

#pragma once

#include "../../Array.h"

#include <cstdint>

namespace lsd {{

namespace detail {{
"""

FILE_ENDING = """
} // namespace detail

} // namespace lsd
"""

CONST_ARRAY_BASE = """\

inline constexpr {} {}[{}]{{
{}
}};
"""

FAST_PATH_FLOAT_ARRAY_SIZE = 39

FAST_PATH_DOUBLE_ARRAY_SIZE = 309


def generateArray(name, type, length, value):
	return CONST_ARRAY_BASE.format(type, name, str(length), value)

def main():
	date = datetime.today()

	# open file and write the opening
	file = open("Tables.h", "+w")
	file.write(FILE_OPENING.format(date.strftime("%Y-%m-%d"), date.year))


	# write powers of ten for floats for the fast path array
	file.write(generateArray("decFloatPowers", "float", FAST_PATH_FLOAT_ARRAY_SIZE, 
						  "".join(f"\t1e{i},\n" for i in range(FAST_PATH_FLOAT_ARRAY_SIZE))[:-2]))

	# write powers of ten for doubles for the fast path array
	file.write(generateArray("decDoublePowers", "double", FAST_PATH_DOUBLE_ARRAY_SIZE,
						  "".join(f"\t1e{i},\n" for i in range(FAST_PATH_DOUBLE_ARRAY_SIZE))[:-2]))


	# calculate table of estimations of power of tens for the eisen lemire algorithm and write it to the file

	powTen = ""

	for i in range(-FAST_PATH_DOUBLE_ARRAY_SIZE + 1, FAST_PATH_DOUBLE_ARRAY_SIZE):
		mantVal = int(5 ** abs(i))

		mant = int()
		expMod = int() # exponent modifier, gets added to 

		if i < 0:
			shiftAmount = int(log2(mantVal)) + 65
			mant = int(2 ** shiftAmount // mantVal)
			expMod = -shiftAmount + 1
		else:
			mant = mantVal
			expMod = mant.bit_length() - 64 # ugly and repeated

		mantBitLenMinus64 = mant.bit_length() - 64
		if mantBitLenMinus64 > 0:
			mant = mant >> mantBitLenMinus64 - 1

			# Rounding algorithm:
			# Imagine if the number had a fractional part. Shifting it to the left would essentialy mean
			# adding a fractional part to the number by however much it was shifted. Rounding applies 
			# when the first digit after the decimal point is higher than 8 (in hex). Instead of trying
			# to extract that digit, we simply shift the number one bit less than it's supposed to shift
			# and check it's last bit, since that would be the bit that has to be set if that hypothetical
			# first digit after the decimal point were to be greater than 8 is now our last bit. Henceforth
			# we can just check for the evenness of the number and simply sound it by just adding one. 
			# Lastly, we shift the number by the remaining bit.
			if mant % 2 == 1:
				mant = mant + 1
			
			mant = mant >> 1
		else:
			mant = mant << abs(mantBitLenMinus64)

		powTen += f"\t{{ UINT64_C({mant:#018x}), {i + expMod} }},\n"
	
	powTen = powTen[:-2]

	file.write(generateArray("powerOfTenTable", "std::pair<std::uint64_t, std::int16_t>", FAST_PATH_DOUBLE_ARRAY_SIZE * 2, powTen))


	# write the file ending and close the file
	file.write(FILE_ENDING)
	file.close()

if __name__ == "__main__":
	main()
